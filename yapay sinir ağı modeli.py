# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Oo21_8gkcN85RjxkbHNGUf8G3bqaWaKD
"""

import numpy as np

class MyNeuralNetwork:
    def __init__(self, n_input, n_hidden1, n_hidden2, n_output):
        # Girdi boyutu, gizli katman boyutları ve çıkış boyutu gibi önemli parametreleri alır
        self.n_input = n_input
        self.n_hidden1 = n_hidden1
        self.n_hidden2 = n_hidden2
        self.n_output = n_output
        
        # Ağırlık matrislerini ve bias vektörlerini rastgele başlatır
        self.weights1 = np.random.randn(self.n_input, self.n_hidden1)
        self.bias1 = np.zeros((1, self.n_hidden1))
        
        self.weights2 = np.random.randn(self.n_hidden1, self.n_hidden2)
        self.bias2 = np.zeros((1, self.n_hidden2))
        
        self.weights3 = np.random.randn(self.n_hidden2, self.n_output)
        self.bias3 = np.zeros((1, self.n_output))
        
    def sigmoid(self, x):
        return 1 / (1 + np.exp(-x))
    
    def sigmoid_derivative(self, x):
        return x * (1 - x)
    
    def forward_propagation(self, X):
        # İleri yayılım işlemini gerçekleştirir
        self.layer1 = self.sigmoid(np.dot(X, self.weights1) + self.bias1)
        self.layer2 = self.sigmoid(np.dot(self.layer1, self.weights2) + self.bias2)
        self.layer3 = self.sigmoid(np.dot(self.layer2, self.weights3) + self.bias3)
        return self.layer3
    
    def backward_propagation(self, X, y, output):
        # Geri yayılım işlemini gerçekleştirir
        self.output_error = y - output
        self.output_delta = self.output_error * self.sigmoid_derivative(output)
        
        self.layer2_error = self.output_delta.dot(self.weights3.T)
        self.layer2_delta = self.layer2_error * self.sigmoid_derivative(self.layer2)
        
        self.layer1_error = self.layer2_delta.dot(self.weights2.T)
        self.layer1_delta = self.layer1_error * self.sigmoid_derivative(self.layer1)
        
    def update_weights(self, X, learning_rate):
        # Ağırlıkları günceller
        self.weights1 += X.T.dot(self.layer1_delta) * learning_rate
        self.bias1 += np.sum(self.layer1_delta, axis=0, keepdims=True) * learning_rate
        
        self.weights2 += self.layer1.T.dot(self.layer2_delta) * learning_rate
        self.bias2 += np.sum(self.layer2_delta, axis=0, keepdims=True) * learning_rate
        
        self.weights3 += self.layer2.T.dot(self.output_delta) * learning_rate
        self.bias3 += np.sum(self.output_delta, axis=0, keepdims=True) * learning_rate
        
    def compute_loss(self, y, output):
        # Kaybı hesaplar
        return np.mean(np.square(y - output))
    
    def train(self, X, y, learning_rate=0.1, epochs=1000):
        # Modeli eğitir
        for i in range(epochs):
            output = self.forward_propagation(X)
            self.backward_propagation(X, y, output)
            self.update_weights(X, learning_rate)
            loss = self.compute_loss(y, output)
            if i % 100 == 0:
                print(f"Epoch {i}, Loss: {loss}")  
    # Ağırlık matrislerinin ve bias vektörlerinin güncellenmesi
    self.W3 -= learning_rate * np.dot(self.a2.T, delta3)
    self.b3 -= learning_rate * np.sum(delta3, axis=0)
    self.W2 -= learning_rate * np.dot(self.a1.T, delta2)
    self.b2 -= learning_rate * np.sum(delta2, axis=0)
    self.W1 -= learning_rate * np.dot(X.T, delta1)
    self.b1 -= learning_rate * np.sum(delta1, axis=0)
    
def fit(self, X, y, epochs, learning_rate):
    """
    Yapay sinir ağı modelinin eğitimi
    :param X: Girdi verileri
    :param y: Gerçek etiketler
    :param epochs: Eğitim sayısı
    :param learning_rate: Öğrenme oranı
    """
    for epoch in range(epochs):
        # İleri yayılım işlemi
        y_hat = self.forward_propagation(X)

        # Geri yayılım işlemi
        self.backward_propagation(X, y, y_hat, learning_rate)
    
def predict(self, X):
    """
    Tahmin işlemi
    :param X: Girdi verileri
    :return: Tahmin edilen etiketler
    """
    y_hat = self.forward_propagation(X)
    predictions = np.round(y_hat)
    return predictions
    #Örnek bir veri kümesi oluşturalım

      X, y = make_classification(n_samples=1000, n_features=5, n_informative=3, n_classes=2, random_state=42)
      y = to_categorical(y)

      #Yapay sinir ağı modelimizi oluşturalım ve eğitelim

      nn = MyNeuralNetwork(n_input=5, n_hidden1=10, n_hidden2=5, n_output=2)
      nn.fit(X, y, epochs=500, learning_rate=0.1)

      #Test verileri üzerinde tahmin yapalım

      X_test, y_test = make_classification(n_samples=100, n_features=5, n_informative=3, n_classes=2, random_state=42)
      y_test = to_categorical(y_test)
      predictions = nn.predict(X_test)

      #Modelimizin doğruluğunu değerlendirelim

      accuracy = np.mean(predictions == y_test)
      print("Model accuracy:", accuracy)